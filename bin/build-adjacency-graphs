#!/usr/bin/env php
<?php

$qwerty = "
`~ 1! 2@ 3# 4$ 5% 6^ 7& 8* 9( 0) -_ =+
    qQ wW eE rR tT yY uU iI oO pP [{ ]} \\|
     aA sS dD fF gG hH jJ kK lL ;: '\"
      zZ xX cC vV bB nN mM ,< .> /?
";
$dvorak = "
`~ 1! 2@ 3# 4$ 5% 6^ 7& 8* 9( 0) [{ ]}
    '\" ,< .> pP yY fF gG cC rR lL /? =+ \\|
     aA oO eE uU iI dD hH tT nN sS -_
      ;: qQ jJ kK xX bB mM wW vV zZ
";
$keypad = "
  / * -
7 8 9 +
4 5 6
1 2 3
  0 .
";
$macKeypad = "
  = / *
7 8 9 -
4 5 6 +
1 2 3
  0 .
";

function getSlantedAdjacentCoords($x, $y)
{
    return [[$x - 1, $y], [$x, $y - 1], [$x + 1, $y - 1], [$x + 1, $y], [$x, $y + 1], [$x - 1, $y + 1],];
}

function getAlignedAdjacentCoords($x, $y)
{
    return [
        [$x - 1, $y],
        [$x - 1, $y - 1],
        [$x, $y - 1],
        [$x + 1, $y - 1],
        [$x + 1, $y],
        [$x + 1, $y + 1],
        [$x, $y + 1],
        [$x - 1, $y + 1]
    ];
}

function adjacencyFunc($x, $y, $slanted)
{
    if ($slanted) {
        return getSlantedAdjacentCoords($x, $y);
    } else {
        return getAlignedAdjacentCoords($x, $y);
    }
}

function buildGraph($layoutStr, $slanted)
{
    $positionTable = [];
    $tokens = array_values(array_filter(array_map(function ($item) {
        $trimmed = trim($item);
        if (!empty($trimmed)) {
            return $trimmed;
        }
    }, preg_split('/[\s]+/', $layoutStr))));

    if (empty($tokens[0])) {
        return '';
    }

    $tokenSize = strlen($tokens[0]);
    $xUnit = $tokenSize + 1;

    foreach ($tokens as $token) {
        assert(strlen($token) == $tokenSize, 'token count mismatch:\n ' . $layoutStr . PHP_EOL);
    }

    foreach (explode("\n", $layoutStr) as $y => $line) {

        if ($slanted) {
            $slant = $y - 1;
        } else {
            $slant = 0;
        }

        foreach (explode(' ', $line) as $token) { // todo needs to be all white space?
            if (empty($token)) {
                continue;
            }

            $strposLessSlant = strpos($line, $token) - $slant;
            $x = floor($strposLessSlant / $xUnit);
            $remainder = $strposLessSlant % $xUnit;
            assert($remainder == 0, sprintf('unexpected x offset for %s in:\n%s', $token, $layoutStr));
            $positionTable[implode('|', [$x, $y])] = $token; // php does not allow arrays (or tuples) as keys
        }
    }

    $adjacencyGraph = [];
    foreach ($positionTable as $position => $chars) {
        $xyCoords = explode('|', $position);
        assert(count($xyCoords) == 2, 'xyCoords is an incorrect length');
        $x = (int)$xyCoords[0];
        $y = (int)$xyCoords[1];

        foreach (str_split($chars) as $char) {
            $adjacencyGraph[(string)$char] = [];
            foreach (adjacencyFunc($x, $y, $slanted) as $coord) {
                $hash = implode('|', $coord);
                array_push(
                    $adjacencyGraph[$char],
                    !empty($positionTable[$hash]) ? $positionTable[$hash] : null
                );
            }
        }
    }

    return $adjacencyGraph;
}

$adjacencyGraphs = [];
$adjacencyGraphMeta = [
    'qwerty' => [$qwerty, true],
    'dvorak' => [$dvorak, true],
    'keypad' => [$keypad, false],
    'mac_keypad' => [$macKeypad, false],
];
foreach ($adjacencyGraphMeta as $graphName => $args) {
    $adjacencyGraphs[$graphName] = call_user_func_array('buildGraph', $args);
}


$outputFile = fopen(__DIR__ . '/../src/Matching/DataProvider/AdjacencyGraphs.php', 'w');
fwrite(
    $outputFile,
    '<?php
/**
 * Generated by bin/build-adjacency-graphs
 */
 
namespace ZxcvbnPhp\\Match\\DataProvider;

/**
 * Class FrequencyLists
 * @package ZxcvbnPhp\Match\DataProvider
 */
class AdjacencyGraphs implements DataProviderInterface
{
    /**
     * @return array
     */
    public static function getData() {
        return ' . var_export($adjacencyGraphs, true) . ';    
    }
}
'
);
